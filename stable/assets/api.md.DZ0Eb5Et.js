import{_ as r,C as p,c as d,o,j as i,a as e,aA as n,G as t,w as l}from"./chunks/framework.B6hD3H-f.js";const Hs=JSON.parse('{"title":"EasyHybrid.jl","description":"","frontmatter":{},"headers":[],"relativePath":"api.md","filePath":"api.md","lastUpdated":null}'),h={name:"api.md"},k={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},H={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},N={class:"jldocstring custom-block",open:""},I={class:"jldocstring custom-block",open:""},P={class:"jldocstring custom-block",open:""},R={class:"jldocstring custom-block",open:""},V={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},O={class:"jldocstring custom-block",open:""},L={class:"jldocstring custom-block",open:""},Q={class:"jldocstring custom-block",open:""},K={class:"jldocstring custom-block",open:""},U={class:"jldocstring custom-block",open:""},z={class:"jldocstring custom-block",open:""},W={class:"jldocstring custom-block",open:""},G={class:"jldocstring custom-block",open:""},q={class:"jldocstring custom-block",open:""},J={class:"jldocstring custom-block",open:""},$={class:"jldocstring custom-block",open:""},Y={class:"jldocstring custom-block",open:""},X={class:"jldocstring custom-block",open:""},Z={class:"jldocstring custom-block",open:""},ss={class:"jldocstring custom-block",open:""},is={class:"jldocstring custom-block",open:""},as={class:"jldocstring custom-block",open:""},ts={class:"jldocstring custom-block",open:""},es={class:"jldocstring custom-block",open:""},ls={class:"jldocstring custom-block",open:""},ns={class:"jldocstring custom-block",open:""},rs={class:"jldocstring custom-block",open:""},ps={class:"jldocstring custom-block",open:""},ds={class:"jldocstring custom-block",open:""},os={class:"jldocstring custom-block",open:""},hs={class:"jldocstring custom-block",open:""},ks={class:"jldocstring custom-block",open:""},ys={class:"jldocstring custom-block",open:""},us={class:"jldocstring custom-block",open:""},gs={class:"jldocstring custom-block",open:""},Es={class:"jldocstring custom-block",open:""},cs={class:"jldocstring custom-block",open:""},bs={class:"jldocstring custom-block",open:""},ms={class:"jldocstring custom-block",open:""},fs={class:"jldocstring custom-block",open:""};function _s(Cs,s,As,Fs,Ts,js){const a=p("Badge");return o(),d("div",null,[s[252]||(s[252]=i("h1",{id:"EasyHybrid.jl",tabindex:"-1"},[e("EasyHybrid.jl "),i("a",{class:"header-anchor",href:"#EasyHybrid.jl","aria-label":'Permalink to "EasyHybrid.jl {#EasyHybrid.jl}"'},"​")],-1)),s[253]||(s[253]=i("p",null,[e("Documentation for "),i("code",null,"EasyHybrid.jl"),e(".")],-1)),i("details",k,[i("summary",null,[s[0]||(s[0]=i("a",{id:"EasyHybrid.EasyHybrid",href:"#EasyHybrid.EasyHybrid"},[i("span",{class:"jlbinding"},"EasyHybrid.EasyHybrid")],-1)),s[1]||(s[1]=e()),t(a,{type:"info",class:"jlObjectType jlModule",text:"Module"})]),s[3]||(s[3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EasyHybrid</span></span></code></pre></div><p>EasyHybrid is a Julia package for hybrid machine learning models, combining neural networks and traditional statistical methods. It provides tools for data preprocessing, model training, and evaluation, making it easier to build and deploy hybrid models.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[2]||(s[2]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",y,[i("summary",null,[s[4]||(s[4]=i("a",{id:"EasyHybrid.BulkDensitySOC",href:"#EasyHybrid.BulkDensitySOC"},[i("span",{class:"jlbinding"},"EasyHybrid.BulkDensitySOC")],-1)),s[5]||(s[5]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[7]||(s[7]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BulkDensitySOC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(NN, predictors, targets, oBD)</span></span></code></pre></div><p>A hybrid model with a neural network <code>NN</code>, <code>predictors</code> and one global parameter oBD.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[6]||(s[6]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",u,[i("summary",null,[s[8]||(s[8]=i("a",{id:"EasyHybrid.BulkDensitySOC-Tuple{Any, Any, NamedTuple}",href:"#EasyHybrid.BulkDensitySOC-Tuple{Any, Any, NamedTuple}"},[i("span",{class:"jlbinding"},"EasyHybrid.BulkDensitySOC")],-1)),s[9]||(s[9]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[11]||(s[11]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BulkDensitySOC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(NN, predictors, oBD)(ds_k)</span></span></code></pre></div><p><strong>Hybrid model for bulk density based on the Federer (1993) paper <a href="http://dx.doi.org/10.1139/x93-131" target="_blank" rel="noreferrer">http://dx.doi.org/10.1139/x93-131</a> plus SOC concentrations, density and coarse fraction</strong></p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[10]||(s[10]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",g,[i("summary",null,[s[12]||(s[12]=i("a",{id:"EasyHybrid.FluxPartModelQ10Lux",href:"#EasyHybrid.FluxPartModelQ10Lux"},[i("span",{class:"jlbinding"},"EasyHybrid.FluxPartModelQ10Lux")],-1)),s[13]||(s[13]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[15]||(s[15]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FluxPartModelQ10Lux</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RUE_NN, Rb_NN, RUE_predictors, Rb_predictors, forcing, targets, Q10)</span></span></code></pre></div><p>A flux partitioning model with separate neural networks for RUE (Radiation Use Efficiency) and Rb (basal respiration), using Q10 temperature sensitivity for respiration calculations.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[14]||(s[14]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",E,[i("summary",null,[s[16]||(s[16]=i("a",{id:"EasyHybrid.FluxPartModelQ10Lux-Tuple{Any, Any, NamedTuple}",href:"#EasyHybrid.FluxPartModelQ10Lux-Tuple{Any, Any, NamedTuple}"},[i("span",{class:"jlbinding"},"EasyHybrid.FluxPartModelQ10Lux")],-1)),s[17]||(s[17]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[19]||(s[19]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FluxPartModelQ10Lux</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RUE_NN, Rb_NN, RUE_predictors, Rb_predictors, forcing, targets, Q10)(ds_k, ps, st)</span></span></code></pre></div><p><strong>Model definition</strong></p><ul><li><p>GPP = SW_IN * RUE(αᵢ(t)) / 12.011 # µmol/m²/s = J/s/m² * g/MJ / g/mol</p></li><li><p>Reco = Rb(βᵢ(t)) * Q10^((T(t) - T_ref)/10)</p></li><li><p>NEE = Reco - GPP</p></li></ul><p>where:</p><ul><li><p>RUE(αᵢ(t)) is the radiation use efficiency predicted by neural network</p></li><li><p>Rb(βᵢ(t)) is the basal respiration predicted by neural network</p></li><li><p>SW_IN is incoming shortwave radiation</p></li><li><p>T(t) is air temperature</p></li><li><p>T_ref is reference temperature (15°C)</p></li><li><p>Q10 is temperature sensitivity factor</p></li></ul>',5)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[18]||(s[18]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",c,[i("summary",null,[s[20]||(s[20]=i("a",{id:"EasyHybrid.FluxPartModel_NEE_ET2-NTuple{4, AbstractArray{Symbol}}",href:"#EasyHybrid.FluxPartModel_NEE_ET2-NTuple{4, AbstractArray{Symbol}}"},[i("span",{class:"jlbinding"},"EasyHybrid.FluxPartModel_NEE_ET2")],-1)),s[21]||(s[21]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[23]||(s[23]=i("p",null,[i("code",null,"FluxPartModel_NEE_ET2"),e("( "),i("code",null,"RUE_predictors"),e("::AbstractArray{Symbol}, "),i("code",null,"Rb_predictors"),e("::AbstractArray{Symbol}, "),i("code",null,"WUE_predictors"),e("::AbstractArray{Symbol}, "),i("code",null,"Ecoeff_predictors"),e("::AbstractArray{Symbol}; forcing=[:SW_IN, :TA], Q10=[1.5f0], neurons=15 )")],-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[22]||(s[22]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",b,[i("summary",null,[s[24]||(s[24]=i("a",{id:"EasyHybrid.FluxPartModel_NEE_ET2-Tuple{Any, Symbol}",href:"#EasyHybrid.FluxPartModel_NEE_ET2-Tuple{Any, Symbol}"},[i("span",{class:"jlbinding"},"EasyHybrid.FluxPartModel_NEE_ET2")],-1)),s[25]||(s[25]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[27]||(s[27]=i("p",null,[e("(m::"),i("code",null,"FluxPartModel_NEE_ET2"),e(")(dk, infer::Symbol)")],-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[26]||(s[26]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",m,[i("summary",null,[s[28]||(s[28]=i("a",{id:"EasyHybrid.FluxPartModel_Q10-Tuple{Any, Any}",href:"#EasyHybrid.FluxPartModel_Q10-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.FluxPartModel_Q10")],-1)),s[29]||(s[29]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[31]||(s[31]=i("p",null,"FluxPartModel_Q10(RUE_predictors, Rb_predictors; Q10=[1.5f0])",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[30]||(s[30]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",f,[i("summary",null,[s[32]||(s[32]=i("a",{id:"EasyHybrid.FluxPartModel_Q10-Tuple{Any, Symbol}",href:"#EasyHybrid.FluxPartModel_Q10-Tuple{Any, Symbol}"},[i("span",{class:"jlbinding"},"EasyHybrid.FluxPartModel_Q10")],-1)),s[33]||(s[33]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[35]||(s[35]=i("p",null,[e("(m::"),i("code",null,"FluxPartModel_Q10"),e(")(dk, infer::Symbol)")],-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[34]||(s[34]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",_,[i("summary",null,[s[36]||(s[36]=i("a",{id:"EasyHybrid.HybridParams",href:"#EasyHybrid.HybridParams"},[i("span",{class:"jlbinding"},"EasyHybrid.HybridParams")],-1)),s[37]||(s[37]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[39]||(s[39]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HybridParams{M</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>A little parametric stub for “the params of function <code>M</code>.” All of your function‐based models become <code>HybridParams{typeof(f)}</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[38]||(s[38]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",C,[i("summary",null,[s[40]||(s[40]=i("a",{id:"EasyHybrid.LinearHM",href:"#EasyHybrid.LinearHM"},[i("span",{class:"jlbinding"},"EasyHybrid.LinearHM")],-1)),s[41]||(s[41]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[43]||(s[43]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LinearHM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(NN, predictors, forcing, targets, β)</span></span></code></pre></div><p>A linear hybrid model with a neural network <code>NN</code>, <code>predictors</code>, <code>forcing</code> and <code>targets</code> terms.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[42]||(s[42]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",A,[i("summary",null,[s[44]||(s[44]=i("a",{id:"EasyHybrid.LinearHM-Tuple{Any, Any, NamedTuple}",href:"#EasyHybrid.LinearHM-Tuple{Any, Any, NamedTuple}"},[i("span",{class:"jlbinding"},"EasyHybrid.LinearHM")],-1)),s[45]||(s[45]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[47]||(s[47]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LinearHM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(NN, predictors, forcing, β)(ds_k)</span></span></code></pre></div><p><strong>Model definition <code>ŷ = α x + β</code></strong></p><p>Apply the linear hybrid model to the input data <code>ds_k</code> (a <code>KeyedArray</code> with proper dimensions). The model uses the neural network <code>NN</code> to compute new <code>α</code>&#39;s based on the <code>predictors</code> and then computes <code>ŷ</code> using the <code>forcing</code> term <code>x</code>.</p><p>Returns:</p><p>A tuple containing the predicted values <code>ŷ</code> and a named tuple with the computed values of <code>α</code> and the state <code>st</code>.</p><p><strong>Example:</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Lux</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EasyHybrid</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Random</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AxisKeys</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ds_k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> KeyedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Float32, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], sample</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Lux</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Chain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dense</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dense</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Instantiate the model</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Note: The model is initialized with a neural network and the predictors and forcing terms</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lh_model </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LinearHM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m, (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rng </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Random</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">default_rng</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Random</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">seed!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rng, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ps, st </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LuxCore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rng, lh_model)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Apply the model to the data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ŷ, αst </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LuxCore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lh_model, ds_k, ps, st)</span></span></code></pre></div>`,7)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[46]||(s[46]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",F,[i("summary",null,[s[48]||(s[48]=i("a",{id:"EasyHybrid.LinearHybridModel-Tuple{AbstractArray{Symbol}, AbstractArray{Symbol}, Int64, Int64}",href:"#EasyHybrid.LinearHybridModel-Tuple{AbstractArray{Symbol}, AbstractArray{Symbol}, Int64, Int64}"},[i("span",{class:"jlbinding"},"EasyHybrid.LinearHybridModel")],-1)),s[49]||(s[49]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[51]||(s[51]=i("p",null,"LinearHybridModel(predictors::AbstractArray{Symbol}, forcing::AbstractArray{Symbol}, out_dim::Int, neurons::Int; b=[1.5f0])",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[50]||(s[50]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",T,[i("summary",null,[s[52]||(s[52]=i("a",{id:"EasyHybrid.LinearHybridModel-Tuple{Any, Symbol}",href:"#EasyHybrid.LinearHybridModel-Tuple{Any, Symbol}"},[i("span",{class:"jlbinding"},"EasyHybrid.LinearHybridModel")],-1)),s[53]||(s[53]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[55]||(s[55]=i("p",null,"(lhm::LinearHybridModel)(df, infer::Symbol)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[54]||(s[54]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",j,[i("summary",null,[s[56]||(s[56]=i("a",{id:"EasyHybrid.LinearHybridModel_2outputs-Tuple{AbstractArray{Symbol}, AbstractArray{Symbol}, Int64, Int64, Any}",href:"#EasyHybrid.LinearHybridModel_2outputs-Tuple{AbstractArray{Symbol}, AbstractArray{Symbol}, Int64, Int64, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.LinearHybridModel_2outputs")],-1)),s[57]||(s[57]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[59]||(s[59]=n('<p><code>LinearHybridModel_2outputs</code>(predictors::AbstractArray{Symbol}, forcing::AbstractArray{Symbol}, <code>out_dim</code>::Int, neurons::Int, <code>nn_chain</code>; a=[1.0f0], b=[1.5f0])</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>- nn_chain :: DenseNN, a Dense neural network</span></span></code></pre></div>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[58]||(s[58]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",v,[i("summary",null,[s[60]||(s[60]=i("a",{id:"EasyHybrid.LinearHybridModel_2outputs-Tuple{Any, Symbol}",href:"#EasyHybrid.LinearHybridModel_2outputs-Tuple{Any, Symbol}"},[i("span",{class:"jlbinding"},"EasyHybrid.LinearHybridModel_2outputs")],-1)),s[61]||(s[61]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[63]||(s[63]=i("p",null,[i("code",null,"LinearHybridModel_2outputs"),e("(df, infer::Symbol)")],-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[62]||(s[62]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",H,[i("summary",null,[s[64]||(s[64]=i("a",{id:"EasyHybrid.LoggingLoss",href:"#EasyHybrid.LoggingLoss"},[i("span",{class:"jlbinding"},"EasyHybrid.LoggingLoss")],-1)),s[65]||(s[65]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[67]||(s[67]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LoggingLoss</span></span></code></pre></div><p>A structure to define a logging loss function for hybrid models. It allows for multiple loss types and an aggregation function to be specified.</p><p><strong>Arguments:</strong></p><ul><li><p><code>loss_types::Vector{Symbol}</code>: A vector of loss types to compute, e.g., <code>[:mse, :mae]</code>.</p></li><li><p><code>training_loss::Symbol</code>: The loss type to use during training, e.g., <code>:mse</code>.</p></li><li><p><code>agg::Function</code>: A function to aggregate the losses, e.g., <code>sum</code> or <code>mean</code>.</p></li><li><p><code>train_mode::Bool</code>: A flag indicating whether the model is in training mode. If <code>true</code>, it uses <code>training_loss</code>; otherwise, it uses <code>loss_types</code>.</p></li></ul>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[66]||(s[66]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",D,[i("summary",null,[s[68]||(s[68]=i("a",{id:"EasyHybrid.RbQ10_2p",href:"#EasyHybrid.RbQ10_2p"},[i("span",{class:"jlbinding"},"EasyHybrid.RbQ10_2p")],-1)),s[69]||(s[69]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[71]||(s[71]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RbQ10_2p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(forcing, targets, Q10)</span></span></code></pre></div>',1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[70]||(s[70]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",x,[i("summary",null,[s[72]||(s[72]=i("a",{id:"EasyHybrid.RbQ10_2p-Tuple{Any, Any, Any}",href:"#EasyHybrid.RbQ10_2p-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.RbQ10_2p")],-1)),s[73]||(s[73]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[75]||(s[75]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RbQ10_2p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(NN, predictors, forcing, targets, Q10)(ds_k)</span></span></code></pre></div><p><strong>Model definition <code>ŷ = Rb(αᵢ(t)) * Q10^((T(t) - T_ref)/10)</code></strong></p><p>ŷ (respiration rate) is computed as a function of the neural network output <code>Rb(αᵢ(t))</code> and the temperature <code>T(t)</code> adjusted by the reference temperature <code>T_ref</code> (default 15°C) using the Q10 temperature sensitivity factor. ````</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[74]||(s[74]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",S,[i("summary",null,[s[76]||(s[76]=i("a",{id:"EasyHybrid.RespirationRbQ10",href:"#EasyHybrid.RespirationRbQ10"},[i("span",{class:"jlbinding"},"EasyHybrid.RespirationRbQ10")],-1)),s[77]||(s[77]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[79]||(s[79]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RespirationRbQ10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(NN, predictors, forcing, targets, Q10)</span></span></code></pre></div><p>A linear hybrid model with a neural network <code>NN</code>, <code>predictors</code>, <code>targets</code> and <code>forcing</code> terms.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[78]||(s[78]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",B,[i("summary",null,[s[80]||(s[80]=i("a",{id:"EasyHybrid.RespirationRbQ10-Tuple{Any, Any, NamedTuple}",href:"#EasyHybrid.RespirationRbQ10-Tuple{Any, Any, NamedTuple}"},[i("span",{class:"jlbinding"},"EasyHybrid.RespirationRbQ10")],-1)),s[81]||(s[81]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[83]||(s[83]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RespirationRbQ10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(NN, predictors, forcing, targets, Q10)(ds_k)</span></span></code></pre></div><p><strong>Model definition <code>ŷ = Rb(αᵢ(t)) * Q10^((T(t) - T_ref)/10)</code></strong></p><p>ŷ (respiration rate) is computed as a function of the neural network output <code>Rb(αᵢ(t))</code> and the temperature <code>T(t)</code> adjusted by the reference temperature <code>T_ref</code> (default 15°C) using the Q10 temperature sensitivity factor. ````</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[82]||(s[82]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",M,[i("summary",null,[s[84]||(s[84]=i("a",{id:"EasyHybrid.Rs_components",href:"#EasyHybrid.Rs_components"},[i("span",{class:"jlbinding"},"EasyHybrid.Rs_components")],-1)),s[85]||(s[85]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[87]||(s[87]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Rs_components</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(NN, predictors, forcing, targets, Q10_het, Q10_root, Q10_myc)</span></span></code></pre></div><p>A linear hybrid model with a neural network <code>NN</code>, <code>predictors</code>, <code>targets</code> and <code>forcing</code> terms.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[86]||(s[86]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",N,[i("summary",null,[s[88]||(s[88]=i("a",{id:"EasyHybrid.Rs_components-Tuple{Any, Any, NamedTuple}",href:"#EasyHybrid.Rs_components-Tuple{Any, Any, NamedTuple}"},[i("span",{class:"jlbinding"},"EasyHybrid.Rs_components")],-1)),s[89]||(s[89]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[91]||(s[91]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Rs_components</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(NN, predictors, forcing, targets, Q10)(ds_k)</span></span></code></pre></div><p><strong>Model definition <code>ŷ = Rb(αᵢ(t)) * Q10^((T(t) - T_ref)/10)</code></strong></p><p>ŷ (respiration rate) is computed as a function of the neural network output <code>Rb(αᵢ(t))</code> and the temperature <code>T(t)</code> adjusted by the reference temperature <code>T_ref</code> (default 15°C) using the Q10 temperature sensitivity factor. ````</p>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[90]||(s[90]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",I,[i("summary",null,[s[92]||(s[92]=i("a",{id:"EasyHybrid.SinusHybridModel-Tuple{Any, Any, Any}",href:"#EasyHybrid.SinusHybridModel-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.SinusHybridModel")],-1)),s[93]||(s[93]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[95]||(s[95]=i("p",null,"SinusHybridModel(predictors, forcing, out_dim; neurons=15, b=[1.5f0])",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[94]||(s[94]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",P,[i("summary",null,[s[96]||(s[96]=i("a",{id:"EasyHybrid.SinusHybridModel-Tuple{Any, Symbol}",href:"#EasyHybrid.SinusHybridModel-Tuple{Any, Symbol}"},[i("span",{class:"jlbinding"},"EasyHybrid.SinusHybridModel")],-1)),s[97]||(s[97]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[99]||(s[99]=i("p",null,"(lhm::SinusHybridModel)(dk, infer::Symbol)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[98]||(s[98]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",R,[i("summary",null,[s[100]||(s[100]=i("a",{id:"EasyHybrid.WrappedTuples",href:"#EasyHybrid.WrappedTuples"},[i("span",{class:"jlbinding"},"EasyHybrid.WrappedTuples")],-1)),s[101]||(s[101]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[103]||(s[103]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WrappedTuples</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{&lt;:NamedTuple}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Wraps a vector of named tuples to allow dot-access to each field as a vector.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[102]||(s[102]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",V,[i("summary",null,[s[104]||(s[104]=i("a",{id:"Base.Multimedia.display-Tuple{T} where T<:AbstractHybridModel",href:"#Base.Multimedia.display-Tuple{T} where T<:AbstractHybridModel"},[i("span",{class:"jlbinding"},"Base.Multimedia.display")],-1)),s[105]||(s[105]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[107]||(s[107]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(io</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, parameter_container</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ParameterContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Display a ParameterContainer containing parameter bounds in a formatted table.</p><p>This function creates a nicely formatted table showing parameter names as row labels and bound types (default, lower, upper) as column headers.</p><p><strong>Arguments</strong></p><ul><li><p><code>io::IO</code>: Output stream</p></li><li><p><code>parameter_container::ParameterContainer</code>: A ParameterContainer with parameter bounds (typically created by <code>build_parameter_matrix</code>)</p></li></ul><p><strong>Returns</strong></p><ul><li>Displays a formatted table using PrettyTables.jl</li></ul><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create parameter defaults and bounds</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parameter_defaults_and_bounds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    θ_s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.464f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.302f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.700f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    α   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.103f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.01f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7.874f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    n   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.163f0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.100f0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20.000f0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Build ParameterContainer and display</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parameter_container </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ParameterContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_defaults_and_bounds)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_container)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># or just parameter_container</span></span></code></pre></div><p><strong>Notes</strong></p><ul><li><p>Requires PrettyTables.jl to be loaded</p></li><li><p>The table shows parameter names as row labels and bound types as column headers</p></li><li><p>Default alignment is right-aligned for all columns</p></li></ul>`,11)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[106]||(s[106]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",w,[i("summary",null,[s[108]||(s[108]=i("a",{id:"EasyHybrid.DenseNN-Tuple{Any, Any, Any}",href:"#EasyHybrid.DenseNN-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.DenseNN")],-1)),s[109]||(s[109]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[111]||(s[111]=i("p",null,[e("DenseNN("),i("code",null,"in_dim"),e(", "),i("code",null,"out_dim"),e(", neurons)")],-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[110]||(s[110]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",O,[i("summary",null,[s[112]||(s[112]=i("a",{id:"EasyHybrid.Dense_RUE_Rb-Tuple{Any}",href:"#EasyHybrid.Dense_RUE_Rb-Tuple{Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.Dense_RUE_Rb")],-1)),s[113]||(s[113]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[115]||(s[115]=i("p",null,[i("code",null,"Dense_RUE_Rb"),e("("),i("code",null,"in_dim"),e("; neurons=15, "),i("code",null,"out_dim"),e("=1, affine=true)")],-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[114]||(s[114]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",L,[i("summary",null,[s[116]||(s[116]=i("a",{id:"EasyHybrid.GRU_NN-Tuple{Any, Any, Any}",href:"#EasyHybrid.GRU_NN-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.GRU_NN")],-1)),s[117]||(s[117]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[119]||(s[119]=i("p",null,[e("GRU_NN("),i("code",null,"in_dim"),e(","),i("code",null,"out_dim"),e(", neurons)")],-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[118]||(s[118]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Q,[i("summary",null,[s[120]||(s[120]=i("a",{id:"EasyHybrid.build_parameter_matrix-Tuple{NamedTuple}",href:"#EasyHybrid.build_parameter_matrix-Tuple{NamedTuple}"},[i("span",{class:"jlbinding"},"EasyHybrid.build_parameter_matrix")],-1)),s[121]||(s[121]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[123]||(s[123]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">build_parameter_matrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_defaults_and_bounds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Build a ComponentArray matrix from a NamedTuple containing parameter defaults and bounds.</p><p>This function converts a NamedTuple where each value is a tuple of (default, lower, upper) bounds into a ComponentArray with named axes for easy parameter management in hybrid models.</p><p><strong>Arguments</strong></p><ul><li><code>parameter_defaults_and_bounds::NamedTuple</code>: A NamedTuple where each key is a parameter name and each value is a tuple of (default, lower, upper) for that parameter.</li></ul><p><strong>Returns</strong></p><ul><li><code>ComponentArray</code>: A 2D ComponentArray with: <ul><li><p>Row axis: Parameter names (from the NamedTuple keys)</p></li><li><p>Column axis: Bound types (:default, :lower, :upper)</p></li><li><p>Data: The parameter values organized in a matrix format</p></li></ul></li></ul><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Define parameter defaults and bounds</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parameter_defaults_and_bounds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    θ_s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.464f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.302f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.700f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Saturated water content [cm³/cm³]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    h_r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1500.0f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1500.0f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1500.0f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Pressure head at residual water content [cm]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    α   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.103f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.01f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7.874f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)),  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Shape parameter [cm⁻¹]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    n   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.163f0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.100f0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20.000f0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)),  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Shape parameter [-]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Build the ComponentArray</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parameter_matrix </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> build_parameter_matrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_defaults_and_bounds)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Access specific parameter bounds</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parameter_matrix</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">θ_s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">default  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get default value for θ_s</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parameter_matrix[:, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:lower</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get all lower bounds</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parameter_matrix[:, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:upper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get all upper bounds</span></span></code></pre></div><p><strong>Notes</strong></p><ul><li><p>The function expects each value in the NamedTuple to be a tuple with exactly 3 elements</p></li><li><p>The order of bounds is always (default, lower, upper)</p></li><li><p>The resulting ComponentArray can be used for parameter optimization and constraint handling</p></li></ul>`,11)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[122]||(s[122]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",K,[i("summary",null,[s[124]||(s[124]=i("a",{id:"EasyHybrid.build_parameters-Tuple{NamedTuple, DataType}",href:"#EasyHybrid.build_parameters-Tuple{NamedTuple, DataType}"},[i("span",{class:"jlbinding"},"EasyHybrid.build_parameters")],-1)),s[125]||(s[125]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[127]||(s[127]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">build_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameters</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AbstractHybridModel</span></span></code></pre></div><p>Constructs a parameter container from a named tuple of parameter bounds and wraps it in a user-defined subtype of <code>AbstractHybridModel</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>parameters::NamedTuple</code>: Named tuple where each entry is a tuple of (default, lower, upper) bounds for a parameter.</p></li><li><p><code>f::DataType</code>: A constructor for a subtype of <code>AbstractHybridModel</code> that takes a <code>ParameterContainer</code> as its argument.</p></li></ul><p><strong>Returns</strong></p><ul><li>An instance of the user-defined <code>AbstractHybridModel</code> subtype containing the parameter container.</li></ul>',6)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[126]||(s[126]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",U,[i("summary",null,[s[128]||(s[128]=i("a",{id:"EasyHybrid.compute_bulk_density-Tuple{Any, Any, Any}",href:"#EasyHybrid.compute_bulk_density-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.compute_bulk_density")],-1)),s[129]||(s[129]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[131]||(s[131]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_bulk_density</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SOCconc, oBD, mBD)</span></span></code></pre></div><p><strong>model for bulk density based on the Federer (1993) paper <a href="http://dx.doi.org/10.1139/x93-131" target="_blank" rel="noreferrer">http://dx.doi.org/10.1139/x93-131</a> plus SOC concentrations, density and coarse fraction</strong></p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[130]||(s[130]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",z,[i("summary",null,[s[132]||(s[132]=i("a",{id:"EasyHybrid.compute_loss",href:"#EasyHybrid.compute_loss"},[i("span",{class:"jlbinding"},"EasyHybrid.compute_loss")],-1)),s[133]||(s[133]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[135]||(s[135]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_loss</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ŷ, y, y_nan, targets, training_loss</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, agg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_loss</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ŷ, y, y_nan, targets, loss_types</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{Symbol}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, agg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the loss for the given predictions and targets using the specified training loss (or vector of losses) type and aggregation function.</p><p><strong>Arguments:</strong></p><ul><li><p><code>ŷ</code>: Predicted values.</p></li><li><p><code>y</code>: Target values.</p></li><li><p><code>y_nan</code>: Mask for NaN values.</p></li><li><p><code>targets</code>: The targets for which the loss is computed.</p></li><li><p><code>training_loss::Symbol</code>: The loss type to use during training, e.g., <code>:mse</code>.</p></li><li><p><code>loss_types::Vector{Symbol}</code>: A vector of loss types to compute, e.g., <code>[:mse, :mae]</code>.</p></li><li><p><code>agg::Function</code>: The aggregation function to apply to the computed losses, e.g., <code>sum</code> or <code>mean</code>.</p></li></ul><p>Returns a single loss value if <code>training_loss</code> is provided, or a NamedTuple of losses for each type in <code>loss_types</code>.</p>`,5)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[134]||(s[134]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",W,[i("summary",null,[s[136]||(s[136]=i("a",{id:"EasyHybrid.constructNNModel-Tuple{Vector{Symbol}, Vector{Symbol}}",href:"#EasyHybrid.constructNNModel-Tuple{Vector{Symbol}, Vector{Symbol}}"},[i("span",{class:"jlbinding"},"EasyHybrid.constructNNModel")],-1)),s[137]||(s[137]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[139]||(s[139]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constructNNModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(predictors, targets; hidden_layers, activation, scale_nn_outputs)</span></span></code></pre></div><p>Main constructor: <code>hidden_layers</code> can be either • a <code>Vector{Int}</code> of sizes, or • a <code>Chain</code> of hidden-layer <code>Dense</code> blocks.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[138]||(s[138]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",G,[i("summary",null,[s[140]||(s[140]=i("a",{id:"EasyHybrid.display_parameter_bounds-Tuple{T} where T<:AbstractHybridModel",href:"#EasyHybrid.display_parameter_bounds-Tuple{T} where T<:AbstractHybridModel"},[i("span",{class:"jlbinding"},"EasyHybrid.display_parameter_bounds")],-1)),s[141]||(s[141]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[143]||(s[143]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">display_parameter_bounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_container</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ParameterContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; alignment</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:r</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Legacy function for displaying parameter bounds with custom alignment.</p><p><strong>Arguments</strong></p><ul><li><p><code>parameter_container::ParameterContainer</code>: A ParameterContainer with parameter bounds</p></li><li><p><code>alignment</code>: Alignment for table columns (default: right-aligned for all columns)</p></li></ul><p><strong>Returns</strong></p><ul><li>Displays a formatted table using PrettyTables.jl</li></ul>',6)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[142]||(s[142]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",q,[i("summary",null,[s[144]||(s[144]=i("a",{id:"EasyHybrid.evec-Tuple{NamedTuple}",href:"#EasyHybrid.evec-Tuple{NamedTuple}"},[i("span",{class:"jlbinding"},"EasyHybrid.evec")],-1)),s[145]||(s[145]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[147]||(s[147]=i("p",null,"evec(nt::NamedTuple)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[146]||(s[146]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",J,[i("summary",null,[s[148]||(s[148]=i("a",{id:"EasyHybrid.get_prediction_target_names-Tuple{Any}",href:"#EasyHybrid.get_prediction_target_names-Tuple{Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.get_prediction_target_names")],-1)),s[149]||(s[149]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[151]||(s[151]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_prediction_target_names</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hm)</span></span></code></pre></div><p>Utility function to extract predictor/forcing and target names from a hybrid model.</p><p><strong>Arguments:</strong></p><ul><li><code>hm</code>: The Hybrid Model</li></ul><p>Returns a tuple of (predictors_forcing, targets) names.</p>',5)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[150]||(s[150]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",$,[i("summary",null,[s[152]||(s[152]=i("a",{id:"EasyHybrid.get_predictions_targets-NTuple{6, Any}",href:"#EasyHybrid.get_predictions_targets-NTuple{6, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.get_predictions_targets")],-1)),s[153]||(s[153]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[155]||(s[155]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_predictions_targets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(HM, x, (y_t, y_nan), ps, st, targets)</span></span></code></pre></div><p>Get predictions and targets from the hybrid model and return them along with the NaN mask.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[154]||(s[154]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Y,[i("summary",null,[s[156]||(s[156]=i("a",{id:"EasyHybrid.initialize_plotting_observables-NTuple{9, Any}",href:"#EasyHybrid.initialize_plotting_observables-NTuple{9, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.initialize_plotting_observables")],-1)),s[157]||(s[157]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[159]||(s[159]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">initialize_plotting_observables</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(init_ŷ_train, init_ŷ_val, y_train, y_val, l_init_train, l_init_val, training_loss, agg, monitor_names, target_names)</span></span></code></pre></div><p>Initialize plotting observables for training visualization if the Makie extension is loaded.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[158]||(s[158]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",X,[i("summary",null,[s[160]||(s[160]=i("a",{id:"EasyHybrid.load_timeseries_netcdf-Tuple{AbstractString}",href:"#EasyHybrid.load_timeseries_netcdf-Tuple{AbstractString}"},[i("span",{class:"jlbinding"},"EasyHybrid.load_timeseries_netcdf")],-1)),s[161]||(s[161]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[163]||(s[163]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">load_timeseries_netcdf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; timedim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractString</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;time&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DataFrame</span></span></code></pre></div><p>Reads a NetCDF file where all data variables are 1D over the specified <code>timedim</code> and returns a tidy DataFrame with one row per time step.</p><ul><li><p>Only includes variables whose sole dimension is <code>timedim</code>.</p></li><li><p>Does not attempt to parse or convert time units; all columns are read as-is.</p></li></ul>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[162]||(s[162]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Z,[i("summary",null,[s[164]||(s[164]=i("a",{id:"EasyHybrid.loss_fn",href:"#EasyHybrid.loss_fn"},[i("span",{class:"jlbinding"},"EasyHybrid.loss_fn")],-1)),s[165]||(s[165]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[167]||(s[167]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">loss_fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ŷ, y, y_nan, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{:rmse}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">loss_fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ŷ, y, y_nan, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{:mse}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">loss_fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ŷ, y, y_nan, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{:mae}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">loss_fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ŷ, y, y_nan, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{:pearson}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">loss_fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ŷ, y, y_nan, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{:r2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the loss for the given predictions and targets using the specified loss type.</p><p><strong>Arguments:</strong></p><ul><li><p><code>ŷ</code>: Predicted values.</p></li><li><p><code>y</code>: Target values.</p></li><li><p><code>y_nan</code>: Mask for NaN values.</p></li><li><p><code>::Val{:rmse}</code>: Root Mean Square Error or <code>::Val{:mse}</code>: Mean Square Error or <code>::Val{:mae}</code>: Mean Absolute Error or <code>::Val{:pearson}</code>: Pearson correlation coefficient or <code>::Val{:r2}</code>: R-squared.</p></li></ul><p>You can define additional loss functions as needed by adding more methods to this function.</p><p><strong>Example:</strong></p><p>In your working script just do the following:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EasyHybrid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loss_fn</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EasyHybrid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loss_fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ŷ, y, y_nan, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{:nse}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((ŷ[y_nan] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y[y_nan])</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((y[y_nan] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(y[y_nan]))</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div>`,8)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[166]||(s[166]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ss,[i("summary",null,[s[168]||(s[168]=i("a",{id:"EasyHybrid.lossfn-Tuple{AbstractLuxContainerLayer, Any, Any, Any, Any, LoggingLoss}",href:"#EasyHybrid.lossfn-Tuple{AbstractLuxContainerLayer, Any, Any, Any, Any, LoggingLoss}"},[i("span",{class:"jlbinding"},"EasyHybrid.lossfn")],-1)),s[169]||(s[169]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[171]||(s[171]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lossfn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(HM</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LuxCore.AbstractLuxContainerLayer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, (y_t, y_nan), ps, st, logging</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LoggingLoss</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Arguments:</p><ul><li><p><code>HM::LuxCore.AbstractLuxContainerLayer</code>: The hybrid model to compute the loss for.</p></li><li><p><code>x</code>: Input data for the model.</p></li><li><p><code>(y_t, y_nan)</code>: Tuple containing the target values and a mask for NaN values.</p></li><li><p><code>ps</code>: Parameters of the model.</p></li><li><p><code>st</code>: State of the model.</p></li><li><p><code>logging::LoggingLoss</code>: Logging configuration for the loss function.</p></li></ul>',3)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[170]||(s[170]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",is,[i("summary",null,[s[172]||(s[172]=i("a",{id:"EasyHybrid.make_folds-Tuple{DataFrame}",href:"#EasyHybrid.make_folds-Tuple{DataFrame}"},[i("span",{class:"jlbinding"},"EasyHybrid.make_folds")],-1)),s[173]||(s[173]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[175]||(s[175]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">make_folds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, shuffle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vector{Int}</span></span></code></pre></div><p>Assigns each observation in the DataFrame <code>df</code> to one of <code>k</code> folds for cross-validation.</p><p><strong>Arguments</strong></p><ul><li><p><code>df::DataFrame</code>: The input DataFrame whose rows are to be split into folds.</p></li><li><p><code>k::Int=5</code>: Number of folds to create.</p></li><li><p><code>shuffle=true</code>: Whether to shuffle the data before assigning folds.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>folds::Vector{Int}</code>: A vector of length <code>nrow(df)</code> where each entry is an integer in <code>1:k</code> indicating the fold assignment for that observation.</li></ul>',6)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[174]||(s[174]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",as,[i("summary",null,[s[176]||(s[176]=i("a",{id:"EasyHybrid.prepare_data",href:"#EasyHybrid.prepare_data"},[i("span",{class:"jlbinding"},"EasyHybrid.prepare_data")],-1)),s[177]||(s[177]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[179]||(s[179]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prepare_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hm, data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prepare_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hm, data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">KeyedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prepare_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hm, data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractDimArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prepare_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hm, data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Prepare data for training by extracting predictor/forcing and target variables based on the hybrid model&#39;s configuration.</p><p><strong>Arguments:</strong></p><ul><li><p><code>hm</code>: The Hybrid Model</p></li><li><p><code>data</code>: The input data, which can be a DataFrame, KeyedArray, or DimensionalData array.</p></li></ul><p><strong>Returns:</strong></p><ul><li><p>If <code>data</code> is a DataFrame, KeyedArray returns a tuple of (predictors_forcing, targets) as KeyedArrays.</p></li><li><p>If <code>data</code> is an AbstractDimArray returns a tuple of (predictors_forcing, targets) of AbstractDimArrays.</p></li><li><p>If <code>data</code> is already a Tuple, it is returned as-is.</p></li></ul>`,6)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[178]||(s[178]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ts,[i("summary",null,[s[180]||(s[180]=i("a",{id:"EasyHybrid.prepare_hidden_chain-Tuple{Union{Chain, Vector{Int64}}, Int64, Int64}",href:"#EasyHybrid.prepare_hidden_chain-Tuple{Union{Chain, Vector{Int64}}, Int64, Int64}"},[i("span",{class:"jlbinding"},"EasyHybrid.prepare_hidden_chain")],-1)),s[181]||(s[181]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[183]||(s[183]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prepare_hidden_chain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hidden_layers, in_dim, out_dim; activation, input_batchnorm</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Construct a neural network <code>Chain</code> for use in NN models.</p><p><strong>Arguments</strong></p><ul><li><p><code>hidden_layers::Union{Vector{Int}, Chain}</code>:</p><ul><li><p>If a <code>Vector{Int}</code>, specifies the sizes of each hidden layer. For example, <code>[32, 16]</code> creates two hidden layers with 32 and 16 units, respectively.</p></li><li><p>If a <code>Chain</code>, the user provides a pre-built chain of hidden layers (excluding input/output layers).</p></li></ul></li><li><p><code>in_dim::Int</code>: Number of input features (input dimension).</p></li><li><p><code>out_dim::Int</code>: Number of output features (output dimension).</p></li><li><p><code>activation</code>: Activation function to use in hidden layers (default: <code>tanh</code>).</p></li><li><p><code>input_batchnorm::Bool</code>: If <code>true</code>, applies a <code>BatchNorm</code> layer to the input (default: <code>false</code>).</p></li></ul><p><strong>Returns</strong></p><ul><li>A <code>Chain</code> object representing the full neural network, with the following structure: <ul><li><p>Optional input batch normalization (if <code>input_batchnorm=true</code>)</p></li><li><p>Input layer: <code>Dense(in_dim, h₁, activation)</code> where <code>h₁</code> is the first hidden size</p></li><li><p>Hidden layers: either user-supplied <code>Chain</code> or constructed from <code>hidden_layers</code></p></li><li><p>Output layer: <code>Dense(hₖ, out_dim)</code> where <code>hₖ</code> is the last hidden size</p></li></ul></li></ul><p>where <code>h₁</code> is the first hidden size and <code>hₖ</code> the last.</p>',7)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[182]||(s[182]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",es,[i("summary",null,[s[184]||(s[184]=i("a",{id:"EasyHybrid.scale_single_param-Tuple{Any, Any, AbstractHybridModel}",href:"#EasyHybrid.scale_single_param-Tuple{Any, Any, AbstractHybridModel}"},[i("span",{class:"jlbinding"},"EasyHybrid.scale_single_param")],-1)),s[185]||(s[185]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[187]||(s[187]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scale_single_param</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name, raw_val, parameters)</span></span></code></pre></div><p>Scale a single parameter using the sigmoid scaling function.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[186]||(s[186]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ls,[i("summary",null,[s[188]||(s[188]=i("a",{id:"EasyHybrid.scale_single_param_minmax-Tuple{Any, AbstractHybridModel}",href:"#EasyHybrid.scale_single_param_minmax-Tuple{Any, AbstractHybridModel}"},[i("span",{class:"jlbinding"},"EasyHybrid.scale_single_param_minmax")],-1)),s[189]||(s[189]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[191]||(s[191]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">scale_single_param_minmax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name, hm</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractHybridModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Scale a single parameter using the minmax scaling function.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[190]||(s[190]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ns,[i("summary",null,[s[192]||(s[192]=i("a",{id:"EasyHybrid.select_cols-Tuple{Any, Any, Any}",href:"#EasyHybrid.select_cols-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.select_cols")],-1)),s[193]||(s[193]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[195]||(s[195]=i("p",null,"select_cols(df, predictors, x)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[194]||(s[194]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",rs,[i("summary",null,[s[196]||(s[196]=i("a",{id:"EasyHybrid.select_cols-Tuple{AxisKeys.KeyedArray, Any, Any}",href:"#EasyHybrid.select_cols-Tuple{AxisKeys.KeyedArray, Any, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.select_cols")],-1)),s[197]||(s[197]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[199]||(s[199]=i("p",null,"select_cols(df::KeyedArray, predictors, x)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[198]||(s[198]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ps,[i("summary",null,[s[200]||(s[200]=i("a",{id:"EasyHybrid.select_predictors-Tuple{Any, Any}",href:"#EasyHybrid.select_predictors-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.select_predictors")],-1)),s[201]||(s[201]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[203]||(s[203]=i("p",null,"select_predictors(df, predictors)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[202]||(s[202]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ds,[i("summary",null,[s[204]||(s[204]=i("a",{id:"EasyHybrid.select_predictors-Tuple{AxisKeys.KeyedArray, Any}",href:"#EasyHybrid.select_predictors-Tuple{AxisKeys.KeyedArray, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.select_predictors")],-1)),s[205]||(s[205]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[207]||(s[207]=i("p",null,"select_predictors(dk::KeyedArray, predictors)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[206]||(s[206]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",os,[i("summary",null,[s[208]||(s[208]=i("a",{id:"EasyHybrid.select_variable-Tuple{AxisKeys.KeyedArray, Any}",href:"#EasyHybrid.select_variable-Tuple{AxisKeys.KeyedArray, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.select_variable")],-1)),s[209]||(s[209]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[211]||(s[211]=i("p",null,"select_variable(df::KeyedArray, x)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[210]||(s[210]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",hs,[i("summary",null,[s[212]||(s[212]=i("a",{id:"EasyHybrid.split_data",href:"#EasyHybrid.split_data"},[i("span",{class:"jlbinding"},"EasyHybrid.split_data")],-1)),s[213]||(s[213]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[215]||(s[215]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">split_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, hybridModel; split_by_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, shuffleobs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, split_data_at</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">split_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{DataFrame, KeyedArray}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, hybridModel; split_by_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, shuffleobs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, split_data_at</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, folds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, val_fold</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">split_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractDimArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, hybridModel; split_by_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, shuffleobs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, split_data_at</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">split_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, hybridModel; split_by_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, shuffleobs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, split_data_at</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">split_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple{Tuple, Tuple}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, hybridModel; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Split data into training and validation sets, either randomly, by grouping by ID, or using external fold assignments.</p><p><strong>Arguments:</strong></p><ul><li><p><code>data</code>: The data to split, which can be a DataFrame, KeyedArray, AbstractDimArray, or Tuple</p></li><li><p><code>hybridModel</code>: The hybrid model object used for data preparation</p></li><li><p><code>split_by_id=nothing</code>: Either <code>nothing</code> for random splitting, a <code>Symbol</code> for column-based splitting, or an <code>AbstractVector</code> for custom ID-based splitting</p></li><li><p><code>shuffleobs=false</code>: Whether to shuffle observations during splitting</p></li><li><p><code>split_data_at=0.8</code>: Ratio of data to use for training</p></li><li><p><code>folds</code>: Vector or column name of fold assignments (1..k), one per sample/column for k-fold cross-validation</p></li><li><p><code>val_fold</code>: The validation fold to use when <code>folds</code> is provided</p></li></ul><p><strong>Behavior:</strong></p><ul><li><p>For DataFrame/KeyedArray: Supports random splitting, ID-based splitting, and external fold assignments</p></li><li><p>For AbstractDimArray/Tuple: Random splitting only after data preparation</p></li><li><p>For pre-split Tuple{Tuple, Tuple}: Returns input unchanged</p></li></ul><p><strong>Returns:</strong></p><ul><li><code>((x_train, y_train), (x_val, y_val))</code>: Tuple containing training and validation data pairs</li></ul>`,8)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[214]||(s[214]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ks,[i("summary",null,[s[216]||(s[216]=i("a",{id:"EasyHybrid.split_data-Tuple{DataFrame, Any, Any, Any}",href:"#EasyHybrid.split_data-Tuple{DataFrame, Any, Any, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.split_data")],-1)),s[217]||(s[217]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[219]||(s[219]=i("p",null,"split_data(df::DataFrame, target, xvars, seqID; f=0.8, batchsize=32, shuffle=true, partial=true)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[218]||(s[218]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ys,[i("summary",null,[s[220]||(s[220]=i("a",{id:"EasyHybrid.split_data-Tuple{DataFrame, Any, Any}",href:"#EasyHybrid.split_data-Tuple{DataFrame, Any, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.split_data")],-1)),s[221]||(s[221]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[223]||(s[223]=i("p",null,"split_data(df::DataFrame, target, xvars; f=0.8, batchsize=32, shuffle=true, partial=true)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[222]||(s[222]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",us,[i("summary",null,[s[224]||(s[224]=i("a",{id:"EasyHybrid.to_keyedArray",href:"#EasyHybrid.to_keyedArray"},[i("span",{class:"jlbinding"},"EasyHybrid.to_keyedArray")],-1)),s[225]||(s[225]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[227]||(s[227]=i("p",null,"tokeyedArray(dfg::Union{Vector,GroupedDataFrame{DataFrame}}, vars=All())",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[226]||(s[226]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",gs,[i("summary",null,[s[228]||(s[228]=i("a",{id:"EasyHybrid.to_keyedArray-Tuple{DataFrame}",href:"#EasyHybrid.to_keyedArray-Tuple{DataFrame}"},[i("span",{class:"jlbinding"},"EasyHybrid.to_keyedArray")],-1)),s[229]||(s[229]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[231]||(s[231]=i("p",null,"tokeyedArray(df::DataFrame)",-1)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[230]||(s[230]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",Es,[i("summary",null,[s[232]||(s[232]=i("a",{id:"EasyHybrid.train-Tuple{Any, Any, Any}",href:"#EasyHybrid.train-Tuple{Any, Any, Any}"},[i("span",{class:"jlbinding"},"EasyHybrid.train")],-1)),s[233]||(s[233]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[235]||(s[235]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">train</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hybridModel, data, save_ps; nepochs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, batchsize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, opt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Adam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), patience</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">typemax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Int),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      file_name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, loss_types</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:mse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:r2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], training_loss</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:mse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, agg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sum, train_from</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      random_seed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">161803</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, yscale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">log10, monitor_names</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[], return_model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:best</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      plotting</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, show_progress</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, hybrid_name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">randstring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Train a hybrid model using the provided data and save the training process to a file in JLD2 format. Default output file is <code>trained_model.jld2</code> at the current working directory under <code>output_tmp</code>.</p><p><strong>Arguments:</strong></p><ul><li><p><code>hybridModel</code>: The hybrid model to be trained.</p></li><li><p><code>data</code>: The training data, either a single DataFrame, a single KeyedArray, or a tuple of KeyedArrays.</p></li><li><p><code>save_ps</code>: A tuple of physical parameters to save during training.</p></li></ul><p><strong>Core Training Parameters:</strong></p><ul><li><p><code>nepochs</code>: Number of training epochs (default: 200).</p></li><li><p><code>batchsize</code>: Size of the training batches (default: 10).</p></li><li><p><code>opt</code>: The optimizer to use for training (default: Adam(0.01)).</p></li><li><p><code>patience</code>: The number of epochs to wait before early stopping (default: <code>typemax(Int)</code> -&gt; no early stopping).</p></li></ul><p><strong>Loss and Evaluation:</strong></p><ul><li><p><code>training_loss</code>: The loss type to use during training (default: <code>:mse</code>).</p></li><li><p><code>loss_types</code>: A vector of loss types to compute during training (default: <code>[:mse, :r2]</code>).</p></li><li><p><code>agg</code>: The aggregation function to apply to the computed losses (default: <code>sum</code>).</p></li></ul><p><strong>Data Handling (passed via kwargs):</strong></p><ul><li><p><code>shuffleobs</code>: Whether to shuffle the training data (default: false).</p></li><li><p><code>split_by_id</code>: Column name or function to split data by ID (default: nothing -&gt; no ID-based splitting).</p></li><li><p><code>split_data_at</code>: Fraction of data to use for training when splitting (default: 0.8).</p></li><li><p><code>folds</code>: Vector or column name of fold assignments (1..k), one per sample/column for k-fold cross-validation (default: nothing).</p></li><li><p><code>val_fold</code>: The validation fold to use when <code>folds</code> is provided (default: nothing).</p></li></ul><p><strong>Training State and Reproducibility:</strong></p><ul><li><p><code>train_from</code>: A tuple of physical parameters and state to start training from or an output of <code>train</code> (default: nothing -&gt; new training).</p></li><li><p><code>random_seed</code>: The random seed to use for training (default: 161803).</p></li></ul><p><strong>Output and Monitoring:</strong></p><ul><li><p><code>file_name</code>: The name of the file to save the training process (default: nothing -&gt; &quot;trained_model.jld2&quot;).</p></li><li><p><code>hybrid_name</code>: Name identifier for the hybrid model (default: randomly generated 10-character string).</p></li><li><p><code>return_model</code>: The model to return: <code>:best</code> for the best model, <code>:final</code> for the final model (default: <code>:best</code>).</p></li><li><p><code>monitor_names</code>: A vector of monitor names to track during training (default: <code>[]</code>).</p></li><li><p><code>folder_to_save</code>: Additional folder name string to append to output path (default: &quot;&quot;).</p></li></ul><p><strong>Visualization and UI:</strong></p><ul><li><p><code>plotting</code>: Whether to generate plots during training (default: true).</p></li><li><p><code>show_progress</code>: Whether to show progress bars during training (default: true).</p></li><li><p><code>yscale</code>: The scale to apply to the y-axis for plotting (default: <code>log10</code>).</p></li></ul>`,16)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[234]||(s[234]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",cs,[i("summary",null,[s[236]||(s[236]=i("a",{id:"EasyHybrid.unpack_keyedarray-Tuple{AxisKeys.KeyedArray, Symbol}",href:"#EasyHybrid.unpack_keyedarray-Tuple{AxisKeys.KeyedArray, Symbol}"},[i("span",{class:"jlbinding"},"EasyHybrid.unpack_keyedarray")],-1)),s[237]||(s[237]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[239]||(s[239]=n(`<p>unpack_keyedarray(ka::KeyedArray, variable::Symbol) Extract a single variable from a KeyedArray and return it as a vector.</p><p><strong>Arguments:</strong></p><ul><li><p><code>ka</code>: The KeyedArray to unpack</p></li><li><p><code>variable</code>: Symbol representing the variable to extract</p></li></ul><p><strong>Returns:</strong></p><ul><li>Vector containing the variable data</li></ul><p><strong>Example:</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Extract just SW_IN from a KeyedArray</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sw_in </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unpack_keyedarray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ds_keyed, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:SW_IN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,7)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[238]||(s[238]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",bs,[i("summary",null,[s[240]||(s[240]=i("a",{id:"EasyHybrid.unpack_keyedarray-Tuple{AxisKeys.KeyedArray, Vector{Symbol}}",href:"#EasyHybrid.unpack_keyedarray-Tuple{AxisKeys.KeyedArray, Vector{Symbol}}"},[i("span",{class:"jlbinding"},"EasyHybrid.unpack_keyedarray")],-1)),s[241]||(s[241]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[243]||(s[243]=n(`<p>unpack_keyedarray(ka::KeyedArray, variables::Vector{Symbol}) Extract specified variables from a KeyedArray and return them as a NamedTuple of vectors.</p><p><strong>Arguments:</strong></p><ul><li><p><code>ka</code>: The KeyedArray to unpack</p></li><li><p><code>variables</code>: Vector of symbols representing the variables to extract</p></li></ul><p><strong>Returns:</strong></p><ul><li>NamedTuple with variable names as keys and vectors as values</li></ul><p><strong>Example:</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Extract SW_IN and TA from a KeyedArray</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unpack_keyedarray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ds_keyed, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:SW_IN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:TA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sw_in </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SW_IN</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ta </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TA</span></span></code></pre></div>`,7)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[242]||(s[242]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",ms,[i("summary",null,[s[244]||(s[244]=i("a",{id:"EasyHybrid.unpack_keyedarray-Tuple{AxisKeys.KeyedArray}",href:"#EasyHybrid.unpack_keyedarray-Tuple{AxisKeys.KeyedArray}"},[i("span",{class:"jlbinding"},"EasyHybrid.unpack_keyedarray")],-1)),s[245]||(s[245]=e()),t(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),s[247]||(s[247]=n(`<p>unpack_keyedarray(ka::KeyedArray) Extract all variables from a KeyedArray and return them as a NamedTuple of vectors.</p><p><strong>Arguments:</strong></p><ul><li><code>ka</code>: The KeyedArray to unpack</li></ul><p><strong>Returns:</strong></p><ul><li>NamedTuple with all variable names as keys and vectors as values</li></ul><p><strong>Example:</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Extract all variables from a KeyedArray</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unpack_keyedarray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ds_keyed)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Access individual variables</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sw_in </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SW_IN</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ta </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TA</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nee </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">NEE</span></span></code></pre></div>`,7)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[246]||(s[246]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",fs,[i("summary",null,[s[248]||(s[248]=i("a",{id:"EasyHybrid.@hybrid-Tuple{Any, Vararg{Any}}",href:"#EasyHybrid.@hybrid-Tuple{Any, Vararg{Any}}"},[i("span",{class:"jlbinding"},"EasyHybrid.@hybrid")],-1)),s[249]||(s[249]=e()),t(a,{type:"info",class:"jlObjectType jlMacro",text:"Macro"})]),s[251]||(s[251]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@hybrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ModelName α β γ</span></span></code></pre></div><p>Macro to define hybrid model structs with arbitrary numbers of physical parameters.</p><p>This defines a struct with:</p><ul><li><p>Default fields: <code>NN</code> (neural network), <code>predictors</code>, <code>forcing</code>, <code>targets</code>.</p></li><li><p>Additional physical parameters, i.e., <code>α β γ</code>.</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@hybrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MyModel α β γ</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@hybrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FluidModel (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:viscosity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:density</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@hybrid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SimpleModel </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:a</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :b</span></span></code></pre></div>`,6)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[250]||(s[250]=[i("a",{href:"https://github.com/EarthyScience/EasyHybrid.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const Ds=r(h,[["render",_s]]);export{Hs as __pageData,Ds as default};
